<!-- Live Map Widget -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />

<div class="bg-white rounded-lg shadow overflow-hidden relative" style="height: 500px;">
    <div id="command-map" class="h-full w-full z-0"></div>

    <!-- Floating Map Controls -->
    <div class="absolute top-4 left-4 z-[400] bg-white px-2 py-2 rounded shadow flex flex-col gap-2">
        <button onclick="toggleLayer('markers')" id="btn-markers" class="p-2 rounded hover:bg-gray-100 transition bg-blue-50 text-blue-600" title="Toggle Markers">
            <i class="fas fa-map-marker-alt"></i>
        </button>
        <button onclick="toggleLayer('heatmap')" id="btn-heatmap" class="p-2 rounded hover:bg-gray-100 transition text-gray-600" title="Toggle Heatmap">
            <i class="fas fa-fire"></i>
        </button>
    </div>

    <!-- Floating Status Pill -->
    <div class="absolute top-4 right-4 z-[400] bg-white px-3 py-1 rounded-full shadow flex items-center gap-2">
        <span class="relative flex h-3 w-3">
            <span id="ping-dot"
                class="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
            <span id="status-dot" class="relative inline-flex rounded-full h-3 w-3 bg-green-500"></span>
        </span>
        <span id="connection-text" class="text-xs font-bold text-gray-700">LIVE</span>
    </div>
</div>

<!-- Audio for alerts -->
<audio id="alert-sound" src="https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3" preload="auto"></audio>

<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
<script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
<script src="/socket.io/socket.io.js"></script>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        // --- Map Setup ---
        const map = L.map('command-map').setView([30.0444, 31.2357], 12);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

        const clusterGroup = L.markerClusterGroup().addTo(map);
        const heatmapLayer = L.heatLayer([], { radius: 25, blur: 15 });
        
        const markers = {}; // Store markers by ID "type_id"
        const userMarkers = {}; // Store markers by userId
        const sitePolygons = {};
        const patrols = {}; // Store patrol data by runId
        const incidentPoints = []; // For heatmap

        window.toggleLayer = function(type) {
            const btnM = document.getElementById('btn-markers');
            const btnH = document.getElementById('btn-heatmap');

            if (type === 'heatmap') {
                map.removeLayer(clusterGroup);
                map.addLayer(heatmapLayer);
                btnH.classList.add('bg-blue-50', 'text-blue-600');
                btnM.classList.remove('bg-blue-50', 'text-blue-600');
            } else {
                map.removeLayer(heatmapLayer);
                map.addLayer(clusterGroup);
                btnM.classList.add('bg-blue-50', 'text-blue-600');
                btnH.classList.remove('bg-blue-50', 'text-blue-600');
            }
        };

        // --- Icons ---
        const getIncidentIcon = (priority) => {
            let color = '#ef4444';
            if (priority === 'critical') color = '#7f1d1d';
            if (priority === 'high') color = '#ef4444';
            if (priority === 'medium') color = '#f59e0b';
            if (priority === 'low') color = '#10b981';

            return L.divIcon({
                className: 'custom-div-icon',
                html: `<div style='background-color: ${color}; width: 14px; height: 14px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 4px black;'></div>`,
                iconSize: [14, 14],
                iconAnchor: [7, 7]
            });
        };

        const panicIcon = L.divIcon({
            className: 'custom-div-icon',
            html: "<div class='animate-ping' style='background-color: #c084fc; width: 20px; height: 20px; border-radius: 50%; opacity: 0.7;'></div><div style='background-color: #7e22ce; width: 12px; height: 12px; border-radius: 50%; position: absolute; top: 4px; left: 4px; border: 2px solid white;'></div>",
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });

        const guardIcon = L.divIcon({
            className: 'custom-div-icon',
            html: "<div style='background-color: #3b82f6; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 4px black;'></div>",
            iconSize: [12, 12],
            iconAnchor: [6, 6]
        });

        // --- Socket Setup ---
        const socket = window.socket || io();
        const statusDot = document.getElementById('status-dot');
        const pingDot = document.getElementById('ping-dot');
        const alertSound = document.getElementById('alert-sound');

        socket.on('connect', () => {
            statusDot.className = 'relative inline-flex rounded-full h-3 w-3 bg-green-500';
            pingDot.classList.remove('hidden');
        });

        socket.on('disconnect', () => {
            statusDot.className = 'relative inline-flex rounded-full h-3 w-3 bg-red-500';
            pingDot.classList.add('hidden');
        });

        // --- Marker Logic ---
        function addMarker(id, type, lat, lng, popupContent, priority = 'medium', isPanic = false) {
            if (!lat || !lng) return;
            const key = `${type}_${id}`;
            if (markers[key]) return;

            const icon = isPanic ? panicIcon : getIncidentIcon(priority);
            const marker = L.marker([lat, lng], { icon }).bindPopup(popupContent);
            
            if (isPanic) {
                marker.addTo(map);
                map.setView([lat, lng], 16);
                alertSound.play().catch(e => console.log("Audio blocked", e));
            } else {
                clusterGroup.addLayer(marker);
                
                if (type === 'incident') {
                    let intensity = 0.5;
                    if (priority === 'critical') intensity = 1.0;
                    if (priority === 'high') intensity = 0.8;
                    incidentPoints.push([lat, lng, intensity]);
                    heatmapLayer.setLatLngs(incidentPoints);
                }
            }
            
            markers[key] = marker;
        }

        function removeMarker(id, type) {
            const key = `${type}_${id}`;
            if (markers[key]) {
                clusterGroup.removeLayer(markers[key]);
                map.removeLayer(markers[key]);
                delete markers[key];
            }
        }

        function updateUserMarker(data) {
            if (userMarkers[data.userId]) {
                userMarkers[data.userId].setLatLng([data.lat, data.lng]);
                userMarkers[data.userId].setPopupContent(`<b>${data.name}</b><br><span class='text-xs text-gray-500'>${data.role}</span>`);
            } else {
                const marker = L.marker([data.lat, data.lng], { icon: guardIcon })
                    .bindPopup(`<b>${data.name}</b><br><span class='text-xs text-gray-500'>${data.role}</span>`);
                clusterGroup.addLayer(marker);
                userMarkers[data.userId] = marker;
            }
        }

        // --- Initialize State ---
        fetch('/incidents/active')
            .then(res => res.json())
            .then(data => {
                const bounds = [];
                data.incidents.forEach(inc => {
                    if (inc.location) {
                        const lat = inc.location.coordinates[0];
                        const lng = inc.location.coordinates[1];
                        addMarker(inc.id, 'incident', lat, lng, `<b>${inc.type}</b> (Priority: ${inc.priority})<br>${inc.description}<br><a href="/incidents/${inc.id}">View</a>`, inc.priority);
                        bounds.push([lat, lng]);
                    }
                });
                data.panics.forEach(panic => {
                    if (panic.location) {
                        const lat = panic.location.coordinates[0];
                        const lng = panic.location.coordinates[1];
                        addMarker(panic.id, 'panic', lat, lng, `<b>PANIC ALERT</b><br>Guard ID: ${panic.guardId}`, 'critical', true);
                        bounds.push([lat, lng]);
                    }
                });
                if (bounds.length > 0) map.fitBounds(bounds, { padding: [50, 50] });
            });

        fetch('/sites')
            .then(res => res.json())
            .then(data => {
                data.sites.forEach(site => {
                    if (site.boundaries) {
                        try {
                            const latlngs = JSON.parse(site.boundaries);
                            const polygon = L.polygon(latlngs, { color: '#3b82f6', weight: 2, opacity: 0.5, fillOpacity: 0.1 }).addTo(map);
                            polygon.bindPopup(`<b>Site: ${site.name}</b><br>Geofence Active`);
                            sitePolygons[site.id] = polygon;
                        } catch (e) { console.error(e); }
                    }
                });
            });

        // --- Socket Listeners ---
        socket.on('active_users_list', (users) => users.forEach(u => updateUserMarker(u)));
        socket.on('user_location_update', (data) => updateUserMarker(data));
        socket.on('location_batch', (updates) => updates.forEach(u => updateUserMarker(u)));
        socket.on('user_disconnected', (userId) => {
            if (userMarkers[userId]) {
                clusterGroup.removeLayer(userMarkers[userId]);
                delete userMarkers[userId];
            }
        });

        socket.on('new_incident', (inc) => {
            if (inc.location) {
                const lat = inc.location.coordinates[0];
                const lng = inc.location.coordinates[1];
                addMarker(inc.id, 'incident', lat, lng, `<b>${inc.type}</b> (Priority: ${inc.priority})<br>${inc.description}`, inc.priority);
            }
        });

        socket.on('panic_alert', (panic) => {
            if (panic.location) {
                addMarker(panic.id, 'panic', panic.location.lat, panic.location.lng, `<b>PANIC ALERT</b><br>${panic.guard}`, 'critical', true);
            }
        });

        socket.on('incident_resolved', (data) => removeMarker(data.incidentId, 'incident'));
        socket.on('panic_resolved', (data) => removeMarker(data.id, 'panic'));

        socket.on('patrol_started', (data) => {
            fetch(`/sites/${data.siteId}`)
                .then(res => res.json())
                .then(siteData => {
                    const template = siteData.site.patrolRuns.find(pr => pr.id === data.runId)?.template;
                    if (template) {
                        updatePatrolVisualization({
                            runId: data.runId,
                            siteId: data.siteId,
                            checkpoints: template.checkpoints,
                            scannedCheckpoints: []
                        });
                    }
                });
        });

        socket.on('patrol_completed', (data) => {
            if (patrols[data.runId]) {
                patrols[data.runId].polylines.forEach(p => map.removeLayer(p));
                patrols[data.runId].markers.forEach(m => map.removeLayer(m));
                delete patrols[data.runId];
            }
        });

        function updatePatrolVisualization(data) {
            if (!patrols[data.runId]) patrols[data.runId] = { polylines: [], markers: [] };
            patrols[data.runId].polylines.forEach(p => map.removeLayer(p));
            patrols[data.runId].markers.forEach(m => map.removeLayer(m));
            patrols[data.runId].polylines = [];
            patrols[data.runId].markers = [];

            const latLngs = data.checkpoints.map(cp => [cp.lat, cp.lng]).filter(ll => ll[0] && ll[1]);
            if (latLngs.length > 1) {
                const polyline = L.polyline(latLngs, { color: '#3b82f6', weight: 3, opacity: 0.5, dashArray: '5, 10' }).addTo(map);
                patrols[data.runId].polylines.push(polyline);
            }

            data.checkpoints.forEach((cp) => {
                if (!cp.lat || !cp.lng) return;
                const isScanned = data.scannedCheckpoints.includes(cp.id);
                const color = isScanned ? '#10b981' : '#9ca3af';
                const marker = L.circleMarker([cp.lat, cp.lng], {
                    radius: 6, fillColor: color, color: '#fff', weight: 2, opacity: 1, fillOpacity: 0.8
                }).addTo(map).bindPopup(`<b>Checkpoint: ${cp.name}</b><br>Status: ${isScanned ? 'Scanned' : 'Pending'}`);
                patrols[data.runId].markers.push(marker);
            });
        }

        socket.emit('request_active_users');
        socket.emit('join_room', 'command_center');
    });
</script>